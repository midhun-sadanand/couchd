{"ast":null,"code":"// import React, { useEffect, useState } from 'react';\n// import { useParams } from 'react-router-dom';\n// import { sortableContainer, sortableElement } from 'react-sortable-hoc';\n// import { arrayMoveImmutable as arrayMove } from 'array-move';\n// import { supabase } from '../supabaseClient';\n// import MovieCard from '../components/common/MovieCard';\n// import MovieSearch from '../components/common/MovieSearch';\n// import YoutubeSearch from '../components/common/YoutubeSearch';\n// import ShareWatchlist from '../components/common/ShareWatchlist';\n\n// const SortableItem = sortableElement(({ item, onDelete }) => {\n//     return (\n//       <div> {/* Wrapping in a native div element */}\n//         <MovieCard\n//             key={item.id}\n//             id={item.id}\n//             title={item.title}\n//             medium={item.medium}\n//             length={item.length}\n//             date={item.release_date.substring(0, 4)}\n//             synopsis={item.synopsis}\n//             image={item.image}\n//             url={item.url}\n//             onDelete={() => onDelete(item.id, item.medium)}\n//         />\n//       </div>\n//     );\n// });\n\n// const SortableList = sortableContainer(({ items, onDelete }) => {\n//   return (\n//     <div>\n//       {items.map((item, index) => (\n//         <SortableItem key={`item.id`} index={index} item={item} onDelete={onDelete} />\n//       ))}\n//     </div>\n//   );\n// });\n\n// const MediaPage = () => {\n//     const [mediaItems, setMediaItems] = useState([]);\n//     const [watchlistId, setWatchlistId] = useState('');\n//     const [userId, setUserId] = useState('');\n//     const { username, watchlistName } = useParams();\n\n//     useEffect(() => {\n//         const fetchSession = async () => {\n//             let { data: user } = await supabase.auth.getUser();\n//             if (user) {\n//                 setUserId(user.id);\n//             }\n//         };\n\n//         fetchMediaItems();\n//         fetchSession();\n//     }, [watchlistName]);\n\n//     const fetchMediaItems = async () => {\n//         const { data: watchlist } = await supabase\n//             .from('watchlists')\n//             .select('id')\n//             .eq('name', watchlistName)\n//             .single()\n//             .select();\n\n//         if (watchlist) {\n//             const { data: media } = await supabase\n//                 .from('media_items')\n//                 .select('*')\n//                 .eq('watchlist_id', watchlist.id)\n//                 .order('order', { ascending: true });\n\n//             setMediaItems(media || []);\n//         }\n//     };\n\n//     const onSortEnd = async ({ oldIndex, newIndex }) => {\n//         const reorderedItems = arrayMove(mediaItems, oldIndex, newIndex);\n//         setMediaItems(reorderedItems);\n\n//         try {\n//             await Promise.all(reorderedItems.map((item, index) => \n//                 supabase.from('media_items').update({ order: index }).match({ id: item.id })\n//             ));\n//         } catch (error) {\n//             console.error('Error updating order on backend:', error);\n//             // Optionally rollback to previous state\n//             fetchMediaItems();\n//         }\n//     };\n\n//     const onShare = async (friendId) => {\n//         if (!watchlistId) {\n//             alert('Watchlist ID not available');\n//             return;\n//         }\n\n//         const { error } = await supabase\n//             .from('watchlist_shares')\n//             .insert([{\n//                 watchlist_id: watchlistId,\n//                 shared_with_user_id: friendId,\n//                 permission_type: 'edit'\n//             }]);\n\n//         if (error) {\n//             console.error('Failed to share watchlist:', error.message);\n//             alert('Failed to share watchlist.');\n//         } else {\n//             alert('Watchlist shared successfully!');\n//         }\n//     };\n\n//     const handleSelectItem = async (item, type) => {\n//         let newMedia;\n//         if (type === 'youtube') {\n//             const videoUrl = `https://www.youtube.com/watch?v=${item.id.videoId}`;\n//             const imageUrl = item.snippet.thumbnails.high.url;\n//             newMedia = await supabase.from('media_items').insert([{\n//                 title: item.snippet.title,\n//                 medium: 'YouTube',\n//                 watchlist_id: (await supabase.from('watchlists').select('id').eq('name', watchlistName).single()).data.id,\n//                 image: imageUrl,\n//                 url: videoUrl,  // Storing YouTube video URL\n//                 release_date: item.snippet.publishedAt.substring(0, 10),\n//                 order: mediaItems.length\n//             }])\n//             .select();\n//         } else { \n//             const imageUrl = item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : '';\n//             newMedia = await supabase.from('media_items').insert([{\n//                 title: item.title || item.name,\n//                 medium: item.media_type === 'movie' ? 'Movie' : 'TV',\n//                 watchlist_id: (await supabase.from('watchlists').select('id').eq('name', watchlistName).single()).data.id,\n//                 image: imageUrl,\n//                 release_date: item.release_date || '',\n//                 order: mediaItems.length\n//             }])\n//             .select();\n//         }\n\n//         const { data, error } = newMedia;\n//         if (error) {\n//             console.error('Failed to add item:', error.message);\n//         } else {\n//             setMediaItems([...mediaItems, ...data]);\n//         }\n//     };    \n\n//     const handleDeleteMediaItem = async (deletedId, medium) => {\n//         if (window.confirm(`Are you sure you want to delete this ${medium}?`)) {\n//             const { error } = await supabase\n//                 .from('media_items')\n//                 .delete()\n//                 .match({ id: deletedId });\n\n//             if (error) {\n//                 console.error('Error deleting media item:', error.message);\n//             } else {\n//                 setMediaItems(currentMediaItems => currentMediaItems.filter(item => item.id !== deletedId));\n//             }\n//         }\n//     };\n\n//     return (\n//         <div className=\"container mx-auto p-4\">\n//             <h1 className=\"text-xl font-bold\">{`Media in \"${watchlistName}\"`}</h1>\n//             <MovieSearch onSelect={(item) => handleSelectItem(item, 'movie')} />\n//             <YoutubeSearch onSelect={(item) => handleSelectItem(item, 'youtube')} />\n//             <SortableList items={mediaItems} onSortEnd={onSortEnd} onDelete={handleDeleteMediaItem} useDragHandle={true} />\n//             <ShareWatchlist onShare={ShareWatchlist} userId = {userId} /> \n//         </div>\n//     );\n// };\n\n// export default MediaPage;\n\nconst handleSelectItem = async (item, type) => {\n  let newMedia;\n  if (type === 'youtube') {\n    const videoUrl = `https://www.youtube.com/watch?v=${item.id.videoId}`;\n    const imageUrl = item.snippet.thumbnails.high.url;\n    newMedia = await supabase.from('media_items').insert([{\n      title: item.snippet.title,\n      medium: 'YouTube',\n      watchlist_id: (await supabase.from('watchlists').select('id').eq('name', watchlistName).single()).data.id,\n      image: imageUrl,\n      url: videoUrl,\n      // Storing YouTube video URL\n      release_date: item.snippet.publishedAt.substring(0, 10),\n      order: mediaItems.length\n    }]).select();\n  } else {\n    const imageUrl = item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : '';\n    newMedia = await supabase.from('media_items').insert([{\n      title: item.title || item.name,\n      medium: item.media_type === 'movie' ? 'Movie' : 'TV',\n      watchlist_id: (await supabase.from('watchlists').select('id').eq('name', watchlistName).single()).data.id,\n      image: imageUrl,\n      release_date: item.release_date || '',\n      order: mediaItems.length\n    }]).select();\n  }\n  const {\n    data,\n    error\n  } = newMedia;\n  if (error) {\n    console.error('Failed to add item:', error.message);\n  } else {\n    setMediaItems([...mediaItems, ...data]);\n  }\n};\nconst handleDeleteMediaItem = async (deletedId, medium) => {\n  if (window.confirm(`Are you sure you want to delete this ${medium}?`)) {\n    const {\n      error\n    } = await supabase.from('media_items').delete().match({\n      id: deletedId\n    });\n    if (error) {\n      console.error('Error deleting media item:', error.message);\n    } else {\n      setMediaItems(currentMediaItems => currentMediaItems.filter(item => item.id !== deletedId));\n    }\n  }\n};","map":{"version":3,"names":["handleSelectItem","item","type","newMedia","videoUrl","id","videoId","imageUrl","snippet","thumbnails","high","url","supabase","from","insert","title","medium","watchlist_id","select","eq","watchlistName","single","data","image","release_date","publishedAt","substring","order","mediaItems","length","poster_path","name","media_type","error","console","message","setMediaItems","handleDeleteMediaItem","deletedId","window","confirm","delete","match","currentMediaItems","filter"],"sources":["/Users/midhu1/Projects/mediaconsumption/CLIENT/src/pages/MediaPage.js"],"sourcesContent":["// import React, { useEffect, useState } from 'react';\n// import { useParams } from 'react-router-dom';\n// import { sortableContainer, sortableElement } from 'react-sortable-hoc';\n// import { arrayMoveImmutable as arrayMove } from 'array-move';\n// import { supabase } from '../supabaseClient';\n// import MovieCard from '../components/common/MovieCard';\n// import MovieSearch from '../components/common/MovieSearch';\n// import YoutubeSearch from '../components/common/YoutubeSearch';\n// import ShareWatchlist from '../components/common/ShareWatchlist';\n\n// const SortableItem = sortableElement(({ item, onDelete }) => {\n//     return (\n//       <div> {/* Wrapping in a native div element */}\n//         <MovieCard\n//             key={item.id}\n//             id={item.id}\n//             title={item.title}\n//             medium={item.medium}\n//             length={item.length}\n//             date={item.release_date.substring(0, 4)}\n//             synopsis={item.synopsis}\n//             image={item.image}\n//             url={item.url}\n//             onDelete={() => onDelete(item.id, item.medium)}\n//         />\n//       </div>\n//     );\n// });\n\n\n// const SortableList = sortableContainer(({ items, onDelete }) => {\n//   return (\n//     <div>\n//       {items.map((item, index) => (\n//         <SortableItem key={`item.id`} index={index} item={item} onDelete={onDelete} />\n//       ))}\n//     </div>\n//   );\n// });\n\n// const MediaPage = () => {\n//     const [mediaItems, setMediaItems] = useState([]);\n//     const [watchlistId, setWatchlistId] = useState('');\n//     const [userId, setUserId] = useState('');\n//     const { username, watchlistName } = useParams();\n\n//     useEffect(() => {\n//         const fetchSession = async () => {\n//             let { data: user } = await supabase.auth.getUser();\n//             if (user) {\n//                 setUserId(user.id);\n//             }\n//         };\n\n//         fetchMediaItems();\n//         fetchSession();\n//     }, [watchlistName]);\n\n\n//     const fetchMediaItems = async () => {\n//         const { data: watchlist } = await supabase\n//             .from('watchlists')\n//             .select('id')\n//             .eq('name', watchlistName)\n//             .single()\n//             .select();\n\n//         if (watchlist) {\n//             const { data: media } = await supabase\n//                 .from('media_items')\n//                 .select('*')\n//                 .eq('watchlist_id', watchlist.id)\n//                 .order('order', { ascending: true });\n\n//             setMediaItems(media || []);\n//         }\n//     };\n\n//     const onSortEnd = async ({ oldIndex, newIndex }) => {\n//         const reorderedItems = arrayMove(mediaItems, oldIndex, newIndex);\n//         setMediaItems(reorderedItems);\n    \n//         try {\n//             await Promise.all(reorderedItems.map((item, index) => \n//                 supabase.from('media_items').update({ order: index }).match({ id: item.id })\n//             ));\n//         } catch (error) {\n//             console.error('Error updating order on backend:', error);\n//             // Optionally rollback to previous state\n//             fetchMediaItems();\n//         }\n//     };\n\n//     const onShare = async (friendId) => {\n//         if (!watchlistId) {\n//             alert('Watchlist ID not available');\n//             return;\n//         }\n\n//         const { error } = await supabase\n//             .from('watchlist_shares')\n//             .insert([{\n//                 watchlist_id: watchlistId,\n//                 shared_with_user_id: friendId,\n//                 permission_type: 'edit'\n//             }]);\n\n//         if (error) {\n//             console.error('Failed to share watchlist:', error.message);\n//             alert('Failed to share watchlist.');\n//         } else {\n//             alert('Watchlist shared successfully!');\n//         }\n//     };\n\n\n//     const handleSelectItem = async (item, type) => {\n//         let newMedia;\n//         if (type === 'youtube') {\n//             const videoUrl = `https://www.youtube.com/watch?v=${item.id.videoId}`;\n//             const imageUrl = item.snippet.thumbnails.high.url;\n//             newMedia = await supabase.from('media_items').insert([{\n//                 title: item.snippet.title,\n//                 medium: 'YouTube',\n//                 watchlist_id: (await supabase.from('watchlists').select('id').eq('name', watchlistName).single()).data.id,\n//                 image: imageUrl,\n//                 url: videoUrl,  // Storing YouTube video URL\n//                 release_date: item.snippet.publishedAt.substring(0, 10),\n//                 order: mediaItems.length\n//             }])\n//             .select();\n//         } else { \n//             const imageUrl = item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : '';\n//             newMedia = await supabase.from('media_items').insert([{\n//                 title: item.title || item.name,\n//                 medium: item.media_type === 'movie' ? 'Movie' : 'TV',\n//                 watchlist_id: (await supabase.from('watchlists').select('id').eq('name', watchlistName).single()).data.id,\n//                 image: imageUrl,\n//                 release_date: item.release_date || '',\n//                 order: mediaItems.length\n//             }])\n//             .select();\n//         }\n    \n//         const { data, error } = newMedia;\n//         if (error) {\n//             console.error('Failed to add item:', error.message);\n//         } else {\n//             setMediaItems([...mediaItems, ...data]);\n//         }\n//     };    \n\n//     const handleDeleteMediaItem = async (deletedId, medium) => {\n//         if (window.confirm(`Are you sure you want to delete this ${medium}?`)) {\n//             const { error } = await supabase\n//                 .from('media_items')\n//                 .delete()\n//                 .match({ id: deletedId });\n\n//             if (error) {\n//                 console.error('Error deleting media item:', error.message);\n//             } else {\n//                 setMediaItems(currentMediaItems => currentMediaItems.filter(item => item.id !== deletedId));\n//             }\n//         }\n//     };\n\n//     return (\n//         <div className=\"container mx-auto p-4\">\n//             <h1 className=\"text-xl font-bold\">{`Media in \"${watchlistName}\"`}</h1>\n//             <MovieSearch onSelect={(item) => handleSelectItem(item, 'movie')} />\n//             <YoutubeSearch onSelect={(item) => handleSelectItem(item, 'youtube')} />\n//             <SortableList items={mediaItems} onSortEnd={onSortEnd} onDelete={handleDeleteMediaItem} useDragHandle={true} />\n//             <ShareWatchlist onShare={ShareWatchlist} userId = {userId} /> \n//         </div>\n//     );\n// };\n\n// export default MediaPage;\n\n\n\nconst handleSelectItem = async (item, type) => {\n    let newMedia;\n    if (type === 'youtube') {\n        const videoUrl = `https://www.youtube.com/watch?v=${item.id.videoId}`;\n        const imageUrl = item.snippet.thumbnails.high.url;\n        newMedia = await supabase.from('media_items').insert([{\n            title: item.snippet.title,\n            medium: 'YouTube',\n            watchlist_id: (await supabase.from('watchlists').select('id').eq('name', watchlistName).single()).data.id,\n            image: imageUrl,\n            url: videoUrl,  // Storing YouTube video URL\n            release_date: item.snippet.publishedAt.substring(0, 10),\n            order: mediaItems.length\n        }])\n        .select();\n    } else { \n        const imageUrl = item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : '';\n        newMedia = await supabase.from('media_items').insert([{\n            title: item.title || item.name,\n            medium: item.media_type === 'movie' ? 'Movie' : 'TV',\n            watchlist_id: (await supabase.from('watchlists').select('id').eq('name', watchlistName).single()).data.id,\n            image: imageUrl,\n            release_date: item.release_date || '',\n            order: mediaItems.length\n        }])\n        .select();\n    }\n\n    const { data, error } = newMedia;\n    if (error) {\n        console.error('Failed to add item:', error.message);\n    } else {\n        setMediaItems([...mediaItems, ...data]);\n    }\n};    \n\nconst handleDeleteMediaItem = async (deletedId, medium) => {\n    if (window.confirm(`Are you sure you want to delete this ${medium}?`)) {\n        const { error } = await supabase\n            .from('media_items')\n            .delete()\n            .match({ id: deletedId });\n\n        if (error) {\n            console.error('Error deleting media item:', error.message);\n        } else {\n            setMediaItems(currentMediaItems => currentMediaItems.filter(item => item.id !== deletedId));\n        }\n    }\n};"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAIA,MAAMA,gBAAgB,GAAG,MAAAA,CAAOC,IAAI,EAAEC,IAAI,KAAK;EAC3C,IAAIC,QAAQ;EACZ,IAAID,IAAI,KAAK,SAAS,EAAE;IACpB,MAAME,QAAQ,GAAI,mCAAkCH,IAAI,CAACI,EAAE,CAACC,OAAQ,EAAC;IACrE,MAAMC,QAAQ,GAAGN,IAAI,CAACO,OAAO,CAACC,UAAU,CAACC,IAAI,CAACC,GAAG;IACjDR,QAAQ,GAAG,MAAMS,QAAQ,CAACC,IAAI,CAAC,aAAa,CAAC,CAACC,MAAM,CAAC,CAAC;MAClDC,KAAK,EAAEd,IAAI,CAACO,OAAO,CAACO,KAAK;MACzBC,MAAM,EAAE,SAAS;MACjBC,YAAY,EAAE,CAAC,MAAML,QAAQ,CAACC,IAAI,CAAC,YAAY,CAAC,CAACK,MAAM,CAAC,IAAI,CAAC,CAACC,EAAE,CAAC,MAAM,EAAEC,aAAa,CAAC,CAACC,MAAM,CAAC,CAAC,EAAEC,IAAI,CAACjB,EAAE;MACzGkB,KAAK,EAAEhB,QAAQ;MACfI,GAAG,EAAEP,QAAQ;MAAG;MAChBoB,YAAY,EAAEvB,IAAI,CAACO,OAAO,CAACiB,WAAW,CAACC,SAAS,CAAC,CAAC,EAAE,EAAE,CAAC;MACvDC,KAAK,EAAEC,UAAU,CAACC;IACtB,CAAC,CAAC,CAAC,CACFX,MAAM,CAAC,CAAC;EACb,CAAC,MAAM;IACH,MAAMX,QAAQ,GAAGN,IAAI,CAAC6B,WAAW,GAAI,kCAAiC7B,IAAI,CAAC6B,WAAY,EAAC,GAAG,EAAE;IAC7F3B,QAAQ,GAAG,MAAMS,QAAQ,CAACC,IAAI,CAAC,aAAa,CAAC,CAACC,MAAM,CAAC,CAAC;MAClDC,KAAK,EAAEd,IAAI,CAACc,KAAK,IAAId,IAAI,CAAC8B,IAAI;MAC9Bf,MAAM,EAAEf,IAAI,CAAC+B,UAAU,KAAK,OAAO,GAAG,OAAO,GAAG,IAAI;MACpDf,YAAY,EAAE,CAAC,MAAML,QAAQ,CAACC,IAAI,CAAC,YAAY,CAAC,CAACK,MAAM,CAAC,IAAI,CAAC,CAACC,EAAE,CAAC,MAAM,EAAEC,aAAa,CAAC,CAACC,MAAM,CAAC,CAAC,EAAEC,IAAI,CAACjB,EAAE;MACzGkB,KAAK,EAAEhB,QAAQ;MACfiB,YAAY,EAAEvB,IAAI,CAACuB,YAAY,IAAI,EAAE;MACrCG,KAAK,EAAEC,UAAU,CAACC;IACtB,CAAC,CAAC,CAAC,CACFX,MAAM,CAAC,CAAC;EACb;EAEA,MAAM;IAAEI,IAAI;IAAEW;EAAM,CAAC,GAAG9B,QAAQ;EAChC,IAAI8B,KAAK,EAAE;IACPC,OAAO,CAACD,KAAK,CAAC,qBAAqB,EAAEA,KAAK,CAACE,OAAO,CAAC;EACvD,CAAC,MAAM;IACHC,aAAa,CAAC,CAAC,GAAGR,UAAU,EAAE,GAAGN,IAAI,CAAC,CAAC;EAC3C;AACJ,CAAC;AAED,MAAMe,qBAAqB,GAAG,MAAAA,CAAOC,SAAS,EAAEtB,MAAM,KAAK;EACvD,IAAIuB,MAAM,CAACC,OAAO,CAAE,wCAAuCxB,MAAO,GAAE,CAAC,EAAE;IACnE,MAAM;MAAEiB;IAAM,CAAC,GAAG,MAAMrB,QAAQ,CAC3BC,IAAI,CAAC,aAAa,CAAC,CACnB4B,MAAM,CAAC,CAAC,CACRC,KAAK,CAAC;MAAErC,EAAE,EAAEiC;IAAU,CAAC,CAAC;IAE7B,IAAIL,KAAK,EAAE;MACPC,OAAO,CAACD,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAACE,OAAO,CAAC;IAC9D,CAAC,MAAM;MACHC,aAAa,CAACO,iBAAiB,IAAIA,iBAAiB,CAACC,MAAM,CAAC3C,IAAI,IAAIA,IAAI,CAACI,EAAE,KAAKiC,SAAS,CAAC,CAAC;IAC/F;EACJ;AACJ,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}