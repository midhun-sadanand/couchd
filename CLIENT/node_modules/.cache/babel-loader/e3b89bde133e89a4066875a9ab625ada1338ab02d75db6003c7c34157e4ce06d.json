{"ast":null,"code":"// import React, { useEffect, useState } from 'react';\n// import { useParams } from 'react-router-dom';\n// import { sortableContainer, sortableElement } from 'react-sortable-hoc';\n// import { arrayMoveImmutable as arrayMove } from 'array-move';\n// import { supabase } from '../supabaseClient';\n// import MovieCard from '../components/common/MovieCard';\n// import MovieSearch from '../components/common/MovieSearch';\n// import YoutubeSearch from '../components/common/YoutubeSearch';\n// import ShareWatchlist from '../components/common/ShareWatchlist';\n\n// const SortableItem = sortableElement(({ item, onDelete }) => {\n//     return (\n//       <div> {/* Wrapping in a native div element */}\n//         <MovieCard\n//             key={item.id}\n//             id={item.id}\n//             title={item.title}\n//             medium={item.medium}\n//             length={item.length}\n//             date={item.release_date.substring(0, 4)}\n//             synopsis={item.synopsis}\n//             image={item.image}\n//             url={item.url}\n//             onDelete={() => onDelete(item.id, item.medium)}\n//         />\n//       </div>\n//     );\n// });\n\n// const SortableList = sortableContainer(({ items, onDelete }) => {\n//   return (\n//     <div>\n//       {items.map((item, index) => (\n//         <SortableItem key={`item.id`} index={index} item={item} onDelete={onDelete} />\n//       ))}\n//     </div>\n//   );\n// });\n\n// const MediaPage = () => {\n//     const [mediaItems, setMediaItems] = useState([]);\n//     const [watchlistId, setWatchlistId] = useState('');\n//     const [userId, setUserId] = useState('');\n//     const { username, watchlistName } = useParams();\n\n//     useEffect(() => {\n//         const fetchSession = async () => {\n//             let { data: user } = await supabase.auth.getUser();\n//             if (user) {\n//                 setUserId(user.id);\n//             }\n//         };\n\n//         fetchMediaItems();\n//         fetchSession();\n//     }, [watchlistName]);\n\n//     const fetchMediaItems = async () => {\n//         const { data: watchlist } = await supabase\n//             .from('watchlists')\n//             .select('id')\n//             .eq('name', watchlistName)\n//             .single()\n//             .select();\n\n//         if (watchlist) {\n//             const { data: media } = await supabase\n//                 .from('media_items')\n//                 .select('*')\n//                 .eq('watchlist_id', watchlist.id)\n//                 .order('order', { ascending: true });\n\n//             setMediaItems(media || []);\n//         }\n//     };\n\n//     const onSortEnd = async ({ oldIndex, newIndex }) => {\n//         const reorderedItems = arrayMove(mediaItems, oldIndex, newIndex);\n//         setMediaItems(reorderedItems);\n\n//         try {\n//             await Promise.all(reorderedItems.map((item, index) => \n//                 supabase.from('media_items').update({ order: index }).match({ id: item.id })\n//             ));\n//         } catch (error) {\n//             console.error('Error updating order on backend:', error);\n//             // Optionally rollback to previous state\n//             fetchMediaItems();\n//         }\n//     };\n\n//     const onShare = async (friendId) => {\n//         if (!watchlistId) {\n//             alert('Watchlist ID not available');\n//             return;\n//         }\n\n//         const { error } = await supabase\n//             .from('watchlist_shares')\n//             .insert([{\n//                 watchlist_id: watchlistId,\n//                 shared_with_user_id: friendId,\n//                 permission_type: 'edit'\n//             }]);\n\n//         if (error) {\n//             console.error('Failed to share watchlist:', error.message);\n//             alert('Failed to share watchlist.');\n//         } else {\n//             alert('Watchlist shared successfully!');\n//         }\n//     };\n\n//     const handleSelectItem = async (item, type) => {\n//         let newMedia;\n//         if (type === 'youtube') {\n//             const videoUrl = `https://www.youtube.com/watch?v=${item.id.videoId}`;\n//             const imageUrl = item.snippet.thumbnails.high.url;\n//             newMedia = await supabase.from('media_items').insert([{\n//                 title: item.snippet.title,\n//                 medium: 'YouTube',\n//                 watchlist_id: (await supabase.from('watchlists').select('id').eq('name', watchlistName).single()).data.id,\n//                 image: imageUrl,\n//                 url: videoUrl,  // Storing YouTube video URL\n//                 release_date: item.snippet.publishedAt.substring(0, 10),\n//                 order: mediaItems.length\n//             }])\n//             .select();\n//         } else { \n//             const imageUrl = item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : '';\n//             newMedia = await supabase.from('media_items').insert([{\n//                 title: item.title || item.name,\n//                 medium: item.media_type === 'movie' ? 'Movie' : 'TV',\n//                 watchlist_id: (await supabase.from('watchlists').select('id').eq('name', watchlistName).single()).data.id,\n//                 image: imageUrl,\n//                 release_date: item.release_date || '',\n//                 order: mediaItems.length\n//             }])\n//             .select();\n//         }\n\n//         const { data, error } = newMedia;\n//         if (error) {\n//             console.error('Failed to add item:', error.message);\n//         } else {\n//             setMediaItems([...mediaItems, ...data]);\n//         }\n//     };    \n\n//     const handleDeleteMediaItem = async (deletedId, medium) => {\n//         if (window.confirm(`Are you sure you want to delete this ${medium}?`)) {\n//             const { error } = await supabase\n//                 .from('media_items')\n//                 .delete()\n//                 .match({ id: deletedId });\n\n//             if (error) {\n//                 console.error('Error deleting media item:', error.message);\n//             } else {\n//                 setMediaItems(currentMediaItems => currentMediaItems.filter(item => item.id !== deletedId));\n//             }\n//         }\n//     };\n\n//     return (\n//         <div className=\"container mx-auto p-4\">\n//             <h1 className=\"text-xl font-bold\">{`Media in \"${watchlistName}\"`}</h1>\n//             <MovieSearch onSelect={(item) => handleSelectItem(item, 'movie')} />\n//             <YoutubeSearch onSelect={(item) => handleSelectItem(item, 'youtube')} />\n//             <SortableList items={mediaItems} onSortEnd={onSortEnd} onDelete={handleDeleteMediaItem} useDragHandle={true} />\n//             <ShareWatchlist onShare={ShareWatchlist} userId = {userId} /> \n//         </div>\n//     );\n// };\n\n// export default MediaPage;","map":{"version":3,"names":[],"sources":["/Users/midhu1/Projects/mediaconsumption/CLIENT/src/pages/MediaPage.js"],"sourcesContent":["// import React, { useEffect, useState } from 'react';\n// import { useParams } from 'react-router-dom';\n// import { sortableContainer, sortableElement } from 'react-sortable-hoc';\n// import { arrayMoveImmutable as arrayMove } from 'array-move';\n// import { supabase } from '../supabaseClient';\n// import MovieCard from '../components/common/MovieCard';\n// import MovieSearch from '../components/common/MovieSearch';\n// import YoutubeSearch from '../components/common/YoutubeSearch';\n// import ShareWatchlist from '../components/common/ShareWatchlist';\n\n// const SortableItem = sortableElement(({ item, onDelete }) => {\n//     return (\n//       <div> {/* Wrapping in a native div element */}\n//         <MovieCard\n//             key={item.id}\n//             id={item.id}\n//             title={item.title}\n//             medium={item.medium}\n//             length={item.length}\n//             date={item.release_date.substring(0, 4)}\n//             synopsis={item.synopsis}\n//             image={item.image}\n//             url={item.url}\n//             onDelete={() => onDelete(item.id, item.medium)}\n//         />\n//       </div>\n//     );\n// });\n\n\n// const SortableList = sortableContainer(({ items, onDelete }) => {\n//   return (\n//     <div>\n//       {items.map((item, index) => (\n//         <SortableItem key={`item.id`} index={index} item={item} onDelete={onDelete} />\n//       ))}\n//     </div>\n//   );\n// });\n\n// const MediaPage = () => {\n//     const [mediaItems, setMediaItems] = useState([]);\n//     const [watchlistId, setWatchlistId] = useState('');\n//     const [userId, setUserId] = useState('');\n//     const { username, watchlistName } = useParams();\n\n//     useEffect(() => {\n//         const fetchSession = async () => {\n//             let { data: user } = await supabase.auth.getUser();\n//             if (user) {\n//                 setUserId(user.id);\n//             }\n//         };\n\n//         fetchMediaItems();\n//         fetchSession();\n//     }, [watchlistName]);\n\n\n//     const fetchMediaItems = async () => {\n//         const { data: watchlist } = await supabase\n//             .from('watchlists')\n//             .select('id')\n//             .eq('name', watchlistName)\n//             .single()\n//             .select();\n\n//         if (watchlist) {\n//             const { data: media } = await supabase\n//                 .from('media_items')\n//                 .select('*')\n//                 .eq('watchlist_id', watchlist.id)\n//                 .order('order', { ascending: true });\n\n//             setMediaItems(media || []);\n//         }\n//     };\n\n//     const onSortEnd = async ({ oldIndex, newIndex }) => {\n//         const reorderedItems = arrayMove(mediaItems, oldIndex, newIndex);\n//         setMediaItems(reorderedItems);\n    \n//         try {\n//             await Promise.all(reorderedItems.map((item, index) => \n//                 supabase.from('media_items').update({ order: index }).match({ id: item.id })\n//             ));\n//         } catch (error) {\n//             console.error('Error updating order on backend:', error);\n//             // Optionally rollback to previous state\n//             fetchMediaItems();\n//         }\n//     };\n\n//     const onShare = async (friendId) => {\n//         if (!watchlistId) {\n//             alert('Watchlist ID not available');\n//             return;\n//         }\n\n//         const { error } = await supabase\n//             .from('watchlist_shares')\n//             .insert([{\n//                 watchlist_id: watchlistId,\n//                 shared_with_user_id: friendId,\n//                 permission_type: 'edit'\n//             }]);\n\n//         if (error) {\n//             console.error('Failed to share watchlist:', error.message);\n//             alert('Failed to share watchlist.');\n//         } else {\n//             alert('Watchlist shared successfully!');\n//         }\n//     };\n\n\n//     const handleSelectItem = async (item, type) => {\n//         let newMedia;\n//         if (type === 'youtube') {\n//             const videoUrl = `https://www.youtube.com/watch?v=${item.id.videoId}`;\n//             const imageUrl = item.snippet.thumbnails.high.url;\n//             newMedia = await supabase.from('media_items').insert([{\n//                 title: item.snippet.title,\n//                 medium: 'YouTube',\n//                 watchlist_id: (await supabase.from('watchlists').select('id').eq('name', watchlistName).single()).data.id,\n//                 image: imageUrl,\n//                 url: videoUrl,  // Storing YouTube video URL\n//                 release_date: item.snippet.publishedAt.substring(0, 10),\n//                 order: mediaItems.length\n//             }])\n//             .select();\n//         } else { \n//             const imageUrl = item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : '';\n//             newMedia = await supabase.from('media_items').insert([{\n//                 title: item.title || item.name,\n//                 medium: item.media_type === 'movie' ? 'Movie' : 'TV',\n//                 watchlist_id: (await supabase.from('watchlists').select('id').eq('name', watchlistName).single()).data.id,\n//                 image: imageUrl,\n//                 release_date: item.release_date || '',\n//                 order: mediaItems.length\n//             }])\n//             .select();\n//         }\n    \n//         const { data, error } = newMedia;\n//         if (error) {\n//             console.error('Failed to add item:', error.message);\n//         } else {\n//             setMediaItems([...mediaItems, ...data]);\n//         }\n//     };    \n\n//     const handleDeleteMediaItem = async (deletedId, medium) => {\n//         if (window.confirm(`Are you sure you want to delete this ${medium}?`)) {\n//             const { error } = await supabase\n//                 .from('media_items')\n//                 .delete()\n//                 .match({ id: deletedId });\n\n//             if (error) {\n//                 console.error('Error deleting media item:', error.message);\n//             } else {\n//                 setMediaItems(currentMediaItems => currentMediaItems.filter(item => item.id !== deletedId));\n//             }\n//         }\n//     };\n\n//     return (\n//         <div className=\"container mx-auto p-4\">\n//             <h1 className=\"text-xl font-bold\">{`Media in \"${watchlistName}\"`}</h1>\n//             <MovieSearch onSelect={(item) => handleSelectItem(item, 'movie')} />\n//             <YoutubeSearch onSelect={(item) => handleSelectItem(item, 'youtube')} />\n//             <SortableList items={mediaItems} onSortEnd={onSortEnd} onDelete={handleDeleteMediaItem} useDragHandle={true} />\n//             <ShareWatchlist onShare={ShareWatchlist} userId = {userId} /> \n//         </div>\n//     );\n// };\n\n// export default MediaPage;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA"},"metadata":{},"sourceType":"module","externalDependencies":[]}